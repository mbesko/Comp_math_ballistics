# Сравнение точности вычисления произведения чисел с плавающей точкой

## Описание

Данная программа на C++ демонстрирует и сравнивает два метода вычисления произведения большого количества чисел с плавающей точкой двойной точности (`double`):

1.  **Наивное произведение:** Последовательное умножение чисел в цикле.
2.  **Произведение через логарифмы (Log-Sum-Exp):** Использование свойства `a * b = exp(ln(a) + ln(b))` для сведения умножения к суммированию логарифмов с последующим вычислением экспоненты.

Цель проекта — исследовать точность этих методов, сравнивая их результаты с эталонным значением, вычисленным с помощью библиотеки высокоточной арифметики **GMP (GNU Multiple Precision Arithmetic Library)**. Особое внимание уделяется достижению максимальной точности, вплоть до последнего значащего бита (`double`), и проверке влияния порядка операндов на результат (инвариантность к перестановке).

## Представление чисел с плавающей точкой (IEEE 754 `double`)

Стандарт IEEE 754 определяет формат хранения и обработки чисел с плавающей точкой в компьютерах. Тип `double` в C++ обычно соответствует 64-битному формату двойной точности IEEE 754.

### Структура `double` (64 бита):

1.  **Знак (Sign):** 1 бит (0 для положительных, 1 для отрицательных).
2.  **Экспонента (Exponent):** 11 бит. Хранит порядок числа (смещение +1023). Позволяет представлять очень большие и очень маленькие числа.
3.  **Мантисса (Mantissa / Significand):** 52 бита. Хранит значащие цифры числа. Для нормализованных чисел подразумевается еще один скрытый бит (равный 1), давая эффективную точность в 53 бита.

### Ключевые особенности и ограничения:

*   **Ограниченная точность:** `double` может точно представлять примерно 15-17 значащих десятичных цифр. Не все действительные числа (даже простые дроби вроде 0.1) могут быть представлены точно.
*   **Ограниченный диапазон:** Существуют минимальное (`DBL_MIN`, ~2.2e-308) и максимальное (`DBL_MAX`, ~1.8e+308) представимые положительные значения. Выход за эти пределы приводит к **исчезновению порядка (underflow)** (результат становится 0.0 или субнормальным числом) или **переполнению (overflow)** (результат становится +/- бесконечностью).
*   **Ошибки округления:** Результат практически любой арифметической операции с `double` округляется до ближайшего представимого значения. Эти ошибки могут накапливаться в длинных последовательностях вычислений.
*   **Неассоциативность:** Из-за ошибок округления операции сложения и умножения для чисел с плавающей точкой не всегда ассоциативны, то есть `(a + b) + c` может не равняться `a + (b + c)`, и аналогично для умножения. Это основная причина, почему порядок вычислений может влиять на результат наивного произведения.
*   **Специальные значения:**
    *   `+0.0` и `-0.0`: Ноль со знаком.
    *   `+Infinity` и `-Infinity`: Бесконечности (результат переполнения или деления на ноль).
    *   `NaN` (Not a Number): Не-число (результат неопределенных операций вроде 0/0, sqrt(-1), inf - inf).

## Реализация

### 1. Генерация данных

*   Генерируется `NUM_VALUES` (например, 1000) псевдослучайных чисел типа `double`.
*   Используется генератор `std::mt19937` и распределение `std::uniform_real_distribution`.
*   Диапазон генерации (`MIN_VALUE`, `MAX_VALUE`, например, `[0.8, 1.2]`) подбирается так, чтобы итоговое произведение не уходило в экстремальные значения (0.0 или Infinity) слишком быстро, позволяя сравнивать точность алгоритмов.

### 2. Наивное произведение (`naive_product_ld`)

*   Реализовано как простой цикл, перемножающий все числа.
*   **Ключевой момент:** Для минимизации накопления ошибки используется переменная-аккумулятор типа `long double` (если `long double` имеет большую точность, чем `double` на целевой платформе).
*   Каждое входное `double` преобразуется в `long double` перед умножением.
*   Промежуточное произведение `long double` проверяется на конечность (`std::isfinite`).
*   Итоговый результат `long double` преобразуется обратно в `double` перед возвратом.

### 3. Суммирование Кахана (`kahan_sum_ld`)

*   Реализует [алгоритм суммирования Кахана](https://ru.wikipedia.org/wiki/Алгоритм_Кэхэна) для типа `long double`.
*   Этот алгоритм значительно уменьшает ошибку, возникающую при суммировании большого количества чисел с плавающей точкой, за счет отслеживания и компенсации потерянной точности на каждом шаге.
*   Используется для точного суммирования логарифмов в методе Log-Sum-Exp.

### 4. Произведение через Log-Sum-Exp (`log_sum_exp_product_ld`)

*   Для каждого входного `double x`:
    *   Проверяется, что `x > 0`.
    *   Вычисляется натуральный логарифм `logl(x)` с точностью `long double`.
*   Полученные логарифмы (`long double`) суммируются с использованием `kahan_sum_ld`.
*   От итоговой суммы логарифмов (`long double`) вычисляется экспонента `expl()` с точностью `long double`.
*   **Ключевой момент:** Преобразование умножения в сложение позволяет использовать более точные алгоритмы суммирования (Кахан) и часто оказывается более устойчивым к переполнению/исчезновению, если логарифмы суммируются аккуратно.
*   Результат `long double` преобразуется обратно в `double`.

### 5. Эталонное произведение (`gmp_product`)

*   Использует тип `mpf_t` из библиотеки GMP.
*   Точность вычислений GMP задается параметром `GMP_PRECISION_BITS` (например, 256 бит).
*   Каждое входное `double` конвертируется в `mpf_t`, и затем выполняется умножение с высокой точностью.
*   Результат используется как эталон для оценки точности других методов.

### 6. Вычисление ULP-расстояния (`ulp_distance`)

*   ULP (Unit in the Last Place) - это "шаг" между двумя соседними представимыми числами с плавающей точкой.
*   Функция вычисляет, сколько таких шагов находится между двумя входными `double`.
*   Реализация основана на интерпретации битового представления `double` как 64-битного целого числа. Корректно обрабатывает нули, бесконечности и NaN.
*   ULP=0 означает, что числа идентичны на битовом уровне. ULP=1 означает, что числа являются ближайшими соседями.
*   Используется как основная метрика точности: чем меньше ULP-расстояние до эталона GMP (округленного до `double`), тем точнее результат.

### 7. Проверка инвариантности к перестановке

*   После вычислений с исходным порядком данных, массив входных чисел перемешивается (`std::shuffle`).
*   Наивное произведение (LD) и Log-Sum-Exp (LD) вычисляются заново для перемешанных данных.
*   Результаты до и после перемешивания сравниваются с помощью `ulp_distance`.
*   Это позволяет увидеть, насколько каждый метод чувствителен к порядку входных данных (из-за неассоциативности и накопления ошибок).

## Важные моменты и выводы

*   **Точность:** Метод Log-Sum-Exp с суммированием Кахана (особенно при использовании `long double` для промежуточных вычислений) демонстрирует значительно лучшую точность, часто достигая результата, отличающегося от идеального не более чем на 1 ULP. Наивное умножение, даже с `long double`, накапливает больше ошибок.
*   **Стабильность:** Log-Sum-Exp с Каханом обычно инвариантен к перестановке входных данных. Наивное произведение может давать разные результаты для разных порядков одних и тех же чисел из-за накопления ошибок округления на разных этапах.
*   **Роль `long double`:** Использование `long double` для промежуточных вычислений (если он точнее `double`) помогает повысить точность обоих методов, но его влияние заметнее в Log-Sum-Exp, где основная операция - суммирование.
*   **ULP как метрика:** ULP-расстояние является адекватной метрикой для оценки точности вычислений с плавающей точкой на уровне представления чисел.
*   **GMP:** Библиотеки вроде GMP незаменимы для получения эталонных значений при анализе точности стандартных типов данных.

## Сборка и запуск

### Зависимости:

*   Компилятор C++ (поддерживающий C++11 или новее, например, g++)
*   Библиотека GMP (GNU Multiple Precision Arithmetic Library)
    *   Debian/Ubuntu: `sudo apt-get install libgmp-dev`
    *   Fedora/CentOS: `sudo yum install gmp-devel`
    *   macOS (Homebrew): `brew install gmp`

### Компиляция:

Сохраните код в файл (например, `main.cpp`) и выполните в терминале:

```bash
g++ float multiplication.cpp -o float multiplication -std=c++17 -lgmp -lm -O0
